# Convex Hull Optimization

## Introduction

中文稱作斜率優化，是其中一種常見的 DP 優化。

先考慮以下例題：

> [CSES - Monster Game I](https://cses.fi/problemset/task/2084/)
> 
> 有 \\(n\\) 個關卡，每關有一個怪物，通關時必須從第一關開始依序通關。打敗一關的怪物需消耗 \\(sf\\) 的 cost，\\(s\\) 為怪物血量，\\(f\\) 為能力值。你會有一個起始的能力值，每到一關，你可以選擇是否打敗該關怪物，並將能力值更新為 \\(f_i\\)。求打敗第 \\(n\\) 關怪物的最小 cost。

考慮 \\(O(n^2)\\) 的做法，令 \\(dp[i]\\) 為殺掉第 \\(i\\) 關怪物所需花的最少時間。

轉移式為：\\(dp[i]=\underset{i>j}{\min}(dp[j]+f[j]\times s[i])\\)

但是這個複雜度無法解決此題。

### 斜率單調 & 查詢單調
我們觀察一下可以發現，其實並不是所有的候選人 \\(j\\) 都有可能成為轉移來源。由於 \\(f[j]\\) 是遞減的，因此對於\\(j_2>j_1\\)，若有一個 \\(i_1\\) 使得 \\(f[j_1]s[i_1]+dp[j_1]>f[j_2]s[i_1]+dp[j_2]\\)，那麼對於任一個 \\(i_2>i_1\\)，\\(f[j_1]s[i_2]+dp[j_1]>f[j_2]s[i_2]+dp[j_2]\\)也是成立的（因為\\(s[i]\\)遞增），意即在 \\(i_1\\) 之後 \\(j_1\\) 就再也不會被取到了，因為至少有 \\(j_2\\) 做為更好的轉移來源。

我們再觀察一次轉移式：\\(dp[i]=\underset{i>j}{\min}(dp[j]+f[j]\times s[i])\\)。形式其實類似於 \\(y=ax+b\\)，其中 \\(a\\) 與 \\(b\\) 只和 \\(j\\) 有關、\\(x\\) 與 \\(y\\) 只和 \\(i\\) 有關。以剛剛的轉移式來說，對應關係如下：

\\[y=dp[i]\\]
\\[x=s[i]\\]
\\[a=f[j]\\]
\\[b=dp[j]\\]

因此對於所有的 \\(j\\)，我們可以將所有的 \\(y=ax+b\\) 在座標平面上畫出來。這時我們的題目便轉變成：給定一個 \\(x\\)，我們要在一個線集中找出最小的 \\(y\\)。

接下來便要思考如何找最小值。如果要代入每一條直線再取極值才能找到答案，並不會優化複雜度，但我們可以來觀察一下這個線集：

// 對範例輸入畫個圖

可以發現這是一個斜率不斷遞減的線集（從算式中也能看出，作為斜率的 \\(f[j]\\) 是遞減的）。對於每個 \\(x\\)，我們都能在這個線集中找到對應的最小值，如果我們將它們通通標出來，可以發現會形成一個上凸包：

// 畫圖標記上凸包

對任何 \\(x'\\) 而言，\\(x=x'\\) 與這個上凸包的交點便是所求的最小值。要找到這個交點，我們必須維護這個凸包，並支援兩種操作：

- 查詢：對於 \\(x=s[i]\\)，我們要能找出其與凸包的交點。

    // 查最左邊的線，並和下一條比較，下一條比較小就 pop

    // 因為查詢具單調性

- 插入：插入一條新的線

    // 往最右邊插入斜率最小的線，如果有線不在凸包上就 pop 掉

    // 因為斜率具單調性

綜合上述，我們可以使用單調隊列，開一個 deque 完成這兩項操作。具體而言，每算完一個 dp[i]，便將 pair \\((f[i], dp[i])\\) 插入隊列尾端，分別代表直線的 \\(a\\) 與 \\(b\\)；在查詢最小值時，我們不斷比較隊列中第一個與第二個元素，如果將當前的 \\(x\\) 代入

// 補上實作細節

這麼一來複雜度便降到 \\(O(n)\\)，以下是參考的程式碼：

// 貼 code

#### 小結
// 步驟總結
1. 將初始值放入 deque
2. 不斷比較 deque 最前端的兩條線。若第二條線有較好的答案就 pop 掉最前端的線。
3. 不斷比較 deque 最尾端的線與新的直線。若前者在新的線加入後便不在凸包中就 pop 掉，最後插入新的直線。

// 要注意的地方
- 要注意斜率以及查詢的單調性是遞增或遞減，會影響實作（應在頭或尾插入等）
- 注意題目是否會有轉移範圍的限制
- 轉移式改成取 max 也可以做，只是變成建下凸包

#### 另一種思路
// 補上讓 j 為點、i 為線的想法與實作方法

### 斜率單調 & 查詢不單調
我們再來看另一個題目：

// 一個斜率單調但查詢不單調的題目

// 目前只有在 POJ 上找到這類題目，希望可以在其他平台上找到

查詢不再單調，意味著轉移來源不單調，因此我們查詢的時候不能再取最左（右）邊的線來做比較。但是斜率依然是單調的，因此我們可以改為使用二分搜來尋找答案。於是我們需要一個可以支援插入、刪除以及二分搜的資料結構，可以改用 set 來維護，複雜度 \\(O(n\log n)\\)。

這題的範例 code：

// 貼 code

### 斜率不單調
斜率不單調的情況更為複雜，我們不能再使用 deque 或是 set 來維護凸包，以下會介紹幾個解決此問題的方法。

#### CDQ 分治
直接來看一個題目。
> [CSES - Monster Game II](https://cses.fi/problemset/task/2085)
> 
> // 補題敘

題目大致與 [CSES - Monster Game I](https://cses.fi/problemset/task/2084/) 相同，但此題不再保證 \\(f\\) 與 \\(s\\) 的單調性，意即斜率與查詢都不再單調。不過透過 CDQ 分治，我們可以「人為」創造出斜率的單調性。

// 將下列整理

- 遞迴的時候要對斜率做排序：先排左半再排右半，最後合併。
- 取到左半區間時，將直線丟入 set 中
- 取到右半區間時，在 set 中詢問最佳解，像斜率單調那時一樣
- 時間複雜度 \\(O(n\log^2 n)\\)

#### 李超線段樹
看題目之前，先來介紹這個資料結構。

假設現在我們想在平面座標上做兩個操作（強制在線）：
1. 加入一條形式為 \\(y=ax+b\\) 的直線
2. 詢問 \\(x=k\\) 與所有直線交點的 \\(y\\) 的最大值

看起來像是區間修改、單點查詢的題目。我們考慮線段樹的作法，令左右界為值域，每個節點存的東西是一條直線。接著我們來思考如何插入與查詢。

**插入**

如果當前的節點沒有存直線，那我們就直接將要插入的直線存進去。

如果當前的節點已經存直線了，那我們要想辦法將他們合併起來。假設當前節點的區間是 \\(\[L, R)\\)、中點為 \\(mid=\frac{L+R}{2}\\)。要加進去的直線為 \\(f\\)、在節點中的直線為 \\(g\\)，這兩條直線可能會有以下四種情況：
1. 在 \\(\[L, R)\\) 中，\\(f\\) 上的點皆大於 \\(g\\) 上的點。
此情況下 \\(g\\) 上的點便不可能成為答案了，我們直接把 \\(g\\) 拿掉改成 \\(f\\)。

    判斷方式：如果 \\(f\\) 在左右端點處都大於 \\(g\\) 則成立。

2. 在 \\(\[L, R)\\) 中，\\(g\\) 上的點皆大於 \\(f\\) 上的點。
與上一個情況相似，此情況下 \\(f\\) 上的點便不可能成為答案了，我們不做更改。

    判斷方式：如果 \\(g\\) 在左右端點處都大於 \\(f\\) 則成立。

3. 在 \\(\[L, R)\\) 中，\\(f\\) 大於 \\(g\\) 的部分較多。
我們可以將當前區間分為兩個區間：\\(f\\) 比較大的區間與 \\(g\\) 較大的區間，以下稱這兩個區間為 \\(F\\) 和 \\(G\\)，如下圖。我們可以發現 \\(G\\) 一定能被 \\(\[L, mid\]\\) 或 \\(\[mid + 1, R)\\) 其中之一完全包含。我們將 \\(G\\) 向下推，像在線段樹上更新懶惰標記一樣，更新對應的子節點。\\(F\\) 則保留下來存在當前節點。

    // 補圖

    判斷方式：若 \\(f\\) 只在其中一個端點大於 \\(g\\)，且 \\(f\\) 在中點也大於 \\(g\\) 則成立。我們可以觀察 \\(f\\) 在左或右端點大於 \\(g\\) 來判斷要向下推的是左區間還是右區間。

4. 在 \\(\[L, R)\\) 中，\\(f\\) 小於 \\(g\\) 的部分較多。
與上一個情況相似，這次我們將 \\(G\\) 存於當前節點，將 \\(F\\) 向下推。

    判斷方式：若 \\(f\\) 只在其中一個端點大於 \\(g\\)，且 \\(g\\) 在中點大於 \\(f\\) 則成立。一樣，我們可以觀察 \\(f\\) 在左或右端點大於 \\(g\\) 來判斷要向下推的是左區間還是右區間。

由於我們向下推的時候只會推左或右其中一個子區間，這麼做的複雜度為 \\(O(\log C)\\)，其中 \\(C\\) 是值域大小。

// 貼插入的範例 code

**查詢**

類似一般線段樹上的區間修改、單點查詢一樣，我們只看包含 \\(k\\) 的那些區間，並從這些線段中取位於 \\(k\\) 的最大值。

// 貼查詢的範例 code

---

現在我們來看題目，一樣是 [CSES - Monster Game II](https://cses.fi/problemset/task/2085)，但這次我們考慮李超線段樹的作法。

// 從 1~n 依序查詢最小值再插入新直線

// 貼 code

#### 動態凸包
// 希望這一part可以日後再補Q

### 總結
// 幾個重點，需要再整理重寫、添加
- 斜率優化只是能優化特定形式轉移式的轉移複雜度
- 斜率是否單調會影響凸包維護的方式；查詢是否單調會影響尋找轉移來源的方式。

## Exercises
// 題敘與 code 待補

> [CF 1083E - The Fair Nut and Rectangles](https://codeforces.com/contest/1083/problem/E)

> [CF 311B - Cats Transport](https://codeforces.com/contest/311/problem/B)

> [CF 319C - Kalila and Dimna in the Logging Industry](
https://codeforces.com/problemset/problem/319/C)

> [CF 1715E - Long Way Home](https://codeforces.com/problemset/problem/1715/E)

> [CSES - Subarray Squares](https://cses.fi/problemset/task/2086)

> [ICPC WF 2011](https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=3547)

> [TIOJ 1921 - 吐鈔機2](https://tioj.ck.tp.edu.tw/problems/1921)

## References
- [Oi wiki - 斜率優化](https://oi-wiki.org/dp/opt/slope/)
- [TIOJ 建中培訓講義](https://tioj.ck.tp.edu.tw/uploads/attachment/5/27/5.pdf)
- [Algorithms for competetive programming - Convex hull trick](https://cp-algorithms.com/geometry/convex_hull_trick.html)
- [[Tutorial] Convex Hull Trick — Geometry being useful](https://codeforces.com/blog/entry/63823)
- [PEGWiki - Convex hull trick](https://wcipeg.com/wiki/Convex_hull_trick)
- [USACO Guide - Convex Hull Trick](https://usaco.guide/plat/convex-hull-trick?lang=cpp)
- [【學習筆記】動態規劃—斜率優化DP（超詳細）](https://www.cnblogs.com/Xing-Ling/p/11210179.html)
- [Oi wiki - 李超線段樹](https://oi-wiki.org/ds/li-chao-tree/)
- [A Simple Introduction to Li-Chao Segment Tree](https://robert1003.github.io/2020/02/06/li-chao-segment-tree.html)
